{
  "SessionStart": [
    {
      "type": "prompt",
      "prompt": "You are checking for paused feature development work at session start.\n\n## Task\n\n1. Check if `.feature-state.json` exists in the current working directory:\n   ```bash\n   if [ -f \".feature-state.json\" ]; then cat .feature-state.json; fi\n   ```\n\n2. If the file exists and contains a valid feature state:\n   - Read the `currentFeature.name` and `currentFeature.phase`\n   - Check if `pausedAt` field exists (indicates paused feature)\n   - Output a brief, helpful message to the user:\n\n   ```\n   üìã Found paused feature: {name}\n   \n   Current phase: {phase}\n   Last updated: {updatedAt}\n   \n   Run /feature-dev-plus to resume where you left off.\n   ```\n\n3. If the file doesn't exist or is empty:\n   - Output nothing (silent)\n   - Exit immediately\n\n4. If the file is corrupted (invalid JSON):\n   - Output warning:\n   ```\n   ‚ö†Ô∏è Found corrupted .feature-state.json file\n   \n   Please check the file or delete it to start fresh.\n   ```\n\n## Important\n\n- Be brief and helpful\n- Don't block the user from starting new work\n- This is just a friendly reminder, not a requirement\n- Exit immediately after outputting message (if any)"
    }
  ],
  "SubagentStop": [
    {
      "matcher": "feature-dev-plus/(discovery-guide|spec-writer|code-architect|test-designer)",
      "type": "prompt",
      "prompt": "You are updating the feature development state after a subagent completed.\n\n## Context\n\nA feature-dev-plus agent just completed. You need to update the state file to reflect progress.\n\n## Task\n\n1. Determine which agent completed:\n   - Look at the conversation for agent completion messages\n   - Extract agent name: discovery-guide, spec-writer, code-architect, or test-designer\n\n2. Determine the phase transition:\n   - discovery-guide: discovery ‚Üí spec\n   - spec-writer: spec ‚Üí plan\n   - code-architect (planning): plan ‚Üí approval\n   - code-architect (implementation): implementation ‚Üí test\n   - test-designer: test ‚Üí commit\n\n3. Read current state file:\n   ```bash\n   cat .feature-state.json\n   ```\n\n4. Update the state:\n   - Set previous phase to \"completed\"\n   - Set next phase to \"in_progress\" (or \"pending\" if it requires user action like approval)\n   - Update `currentFeature.updatedAt` to current timestamp\n   - Update `currentFeature.phase` to next phase\n   - If agent created files, update relevant paths (specFile, planFile, testFile)\n\n5. Write updated state back to `.feature-state.json`\n\n6. Exit silently (no output to user)\n\n## Important\n\n- This runs after EVERY feature-dev-plus agent completion\n- Be fast and efficient (minimal token usage)\n- Don't output anything to the user (silent operation)\n- Only update state, don't analyze or reason extensively\n- Exit immediately after writing state file"
    }
  ],
  "PreCompact": [
    {
      "type": "prompt",
      "prompt": "You are handling context limit approaching during feature development.\n\n## Context\n\nClaude Code is about to compact the conversation context because it's approaching token limits. This would lose important context for feature development in progress.\n\n## Task\n\n1. Check if feature development is in progress:\n   ```bash\n   if [ -f \".feature-state.json\" ]; then cat .feature-state.json; fi\n   ```\n\n2. If NO state file exists:\n   - Exit silently (return success, allow compaction)\n   - No feature development in progress, compaction is fine\n\n3. If state file exists and feature is in progress:\n\n   a. Read the current state to understand:\n      - Current phase\n      - Current task (if in implementation)\n      - What was last completed\n   \n   b. Enhance the state file with detailed resumption context:\n      - Add `pausedAt` timestamp\n      - Add `pauseReason: \"context_limit\"`\n      - Add or update `resumeContext` with:\n        - `lastAction`: What was just completed\n        - `currentTask`: What's currently being worked on\n        - `nextSteps`: Array of 3-5 next steps to take\n        - `filesInProgress`: Any files currently being created/modified\n   \n   c. Write enhanced state back to file\n   \n   d. Output clear, actionable message to user:\n   ```\n   ‚ö†Ô∏è Context limit approaching. Progress saved to .feature-state.json\n   \n   Feature: {currentFeature.name}\n   Current phase: {currentFeature.phase} (in_progress)\n   Last completed: {resumeContext.lastAction}\n   In progress: {resumeContext.currentTask}\n   \n   Please run /clear to continue with fresh context.\n   When ready, run /feature-dev-plus to resume.\n   ```\n   \n   e. Return FAILURE to block compaction\n      - This prevents compaction from proceeding\n      - Forces user to /clear instead\n      - Ensures clean resumption rather than compacted context\n\n## Why Block Compaction\n\nCompaction loses conversation nuance and context. For feature development, it's better to:\n1. Save complete state to file\n2. User runs /clear (fresh start)\n3. Resume from state file with full context restored\n\nThis gives better results than compacted, degraded context.\n\n## Important\n\n- Only block compaction if feature development is actually in progress\n- Provide clear, actionable instructions to user\n- Make resumeContext detailed enough for Claude to continue seamlessly\n- Return FAILURE (not success) to block compaction\n- Be helpful and reassuring to user (progress is saved)"
    }
  ]
}
